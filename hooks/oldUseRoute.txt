 () => {
   
    const { city, state } = data?.state?.searchResults!

    const path = `/city/${ifWhiteSpaces(city)}/${ifWhiteSpaces(state)}`
  
    

    console.log('WHAT IS DATA IN useRoute', data)


    /* SORT LISTINGS  */
    // if (data.sortListings) {
    //   urlQuery.push(`${data.sortListings.query}=${data.sortListings.slug}`)

    //   updatedCurrentSetFilters = addRemoveCurrentFilters(
    //     `${data.sortListings.id}`,
    //     urlQuery,
    //     data.state!.listings.filters.currentSetFilters
    //   )
    //   return route()
    // }
    /* FILTER LISTINGS  */
    // if (data?.filterListings!) {
    //   const filterId = data?.filterListings?.id!

    //   const handleClearData = () => {
    //     const { filterCategory, query } = data?.filterListings?.props!

    //     const clearFilterBy = {
    //       bedsBaths: () => {
    //         //WHATS IN THE CURRENT FILTERS?
    //         console.log(
    //           'WHATS IN THE CURRENT FILTERS?',
    //           data.state?.listings.filters.currentSetFilters
    //         )
    //         const { currentSetFilters } = data.state?.listings.filters! //1 pass arg

    //         // REMOVE anything with
    //         const bedsBathQueries = new RegExp('min-beds|max-beds|min-baths') //2pass regEx
    //         const rest = currentSetFilters.filter(
    //           (s) => !bedsBathQueries.test(s)
    //         ) //to update the reducer

    //         const currentPath: string = router.asPath

    //         //split the path,
    //         const pathParts: string[] = currentPath.split('/')

    //         //now find the string of queries...  // let filterStringUrl: string[] = pathParts.filter( s=> bedsBathQueries.test(s))
    //         let filterStringUrl: string = pathParts.reduce(
    //           (a, urlPart) => bedsBathQueries.test(urlPart) && urlPart,
    //           ''
    //         )

    //         //if this fails return the currentPath
    //         if (typeof filterStringUrl === 'string') {
    //           //ex.) filterStringUrl= min-beds=2,max-beds=3,min-baths=1.5,homeType=multiFamily,status=for-rent
    //           let filterStringParts = filterStringUrl.split(',')

    //           const updatedUrlQueryString =
    //             '/filters/' +
    //             filterStringParts.reduce((prev, cur) => {
    //               return bedsBathQueries.test(cur) === false
    //                 ? prev + cur + '/'
    //                 : prev + ''
    //             }, '')

    //           const updatedUrl = pathParts
    //             .map((item) => {
    //               if (
    //                 bedsBathQueries.test(item) === true ||
    //                 item === 'filters' ||
    //                 item === 'city'
    //               ) {
    //                 return ''
    //               }
    //               return item
    //             })
    //             .filter((p) => p !== '')

    //           console.log('updatedUrl', updatedUrl) // ['city', 'santa monica', 'ca]
    //           console.log('updatedUrlQueryString', updatedUrlQueryString) // url with removed part

    //           const newUrl = [...updatedUrl]
    //             .join('/')
    //             .concat(updatedUrlQueryString)
    //           console.log('what is newUrl', newUrl)
    //           router.push(newUrl)
    //         }

    //         console.log('is this the right filterStringUrl', filterStringUrl)
    //         //ex.) filterStringUrl = ['homeType=multiFamily,status=for-rent,min-beds=2,max-beds=3,min-baths=2']
    //       },
    //     }

    //     return clearFilterBy[filterCategory]()
    //   }
    //   const filterBy = {
    //     homeType: singleSlug,
    //     status: singleSlug,
    //     baths: singleSlug,
    //     beds: bedsSlugs,
    //     clearData: handleClearData,
    //   }

    //   return filterBy[filterId]()
    // }

  }

  return { handleRoute }
}


///////// SORT \\\\\\\\\\


 switch (param.id) {
      case 'ascend-descend-listings':
        handleRoute({
          state: state,
          sortListings: {
            id: 'sort',
            query: `sort=${param.isAsc ? 'low' : 'high'}`,
            slug: state.listings.sort.criteria,
          },
        })
        dispatch(setIsAscending(param.isAsc, state))
        return

      case 'sort-list':
        const isLowOrHigh = (status: boolean | null) => {
          
          console.log('what is status', status)

          if (status === null || status === undefined) {
            return 'high'
          }

          console.log('what is state.listings.sort.isAscending', state.listings.sort.isAscending)

          return state.listings.sort.isAscending ? 'low' : 'high'
        }

        handleRoute({
          state: state,
          sortListings: {
            id: 'sort',
            query: `sort=${isLowOrHigh(state.listings.sort.isAscending)}`,
            slug: param.slug,
          },
        })
        dispatch(setActiveSortCategory(param.slug, state))
        return

      default:
        return
    }